"use strict";(self.webpackChunkdocsite=self.webpackChunkdocsite||[]).push([[9428],{8300:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>r,metadata:()=>a,toc:()=>c});var o=i(5893),t=i(1151);const r={},s=void 0,a={id:"Implementation Best Practices",title:"Implementation Best Practices",description:"Component Props",source:"@site/../../docs/Implementation Best Practices.md",sourceDirName:".",slug:"/Implementation Best Practices",permalink:"/fluentui-charting-contrib/docs/Implementation Best Practices",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Debugging",permalink:"/fluentui-charting-contrib/docs/Debugging"},next:{title:"Accessibility",permalink:"/fluentui-charting-contrib/docs/Accessibility"}},l={},c=[{value:"Component Props",id:"component-props",level:2},{value:"Prefer property names consistent with other components",id:"prefer-property-names-consistent-with-other-components",level:3},{value:"Prefer to minimally distinguish property names",id:"prefer-to-minimally-distinguish-property-names",level:3},{value:"List properties in alphabetical order",id:"list-properties-in-alphabetical-order",level:3},{value:"Avoid re-declaring properties from native element attributes",id:"avoid-re-declaring-properties-from-native-element-attributes",level:3},{value:"Use discriminated union over boolean for mutually exclusive props",id:"use-discriminated-union-over-boolean-for-mutually-exclusive-props",level:3},{value:"Consider a discriminated union for future additional",id:"consider-a-discriminated-union-for-future-additional",level:3},{value:"Prefer to inline small &amp; independent discriminated unions",id:"prefer-to-inline-small--independent-discriminated-unions",level:3}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",ul:"ul",...(0,t.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"component-props",children:"Component Props"}),"\n",(0,o.jsx)(n.h3,{id:"prefer-property-names-consistent-with-other-components",children:"Prefer property names consistent with other components"}),"\n",(0,o.jsxs)(n.p,{children:["Consistent property names across the component library help developers understand how to use your component more quickly because the names are familiar. When there aren't good examples, check out ",(0,o.jsx)(n.a,{href:"https://open-ui.org/",children:"open-ui.org"})," to see what names are commonly used across UI component libraries and frameworks."]}),"\n",(0,o.jsxs)(n.p,{children:["For example, a property that controls the overall layout and style of a component is most commonly named ",(0,o.jsx)(n.code,{children:"appearance"}),". Avoid naming your property ",(0,o.jsx)(n.code,{children:"display"}),", ",(0,o.jsx)(n.code,{children:"look"}),", etc."]}),"\n",(0,o.jsxs)(n.p,{children:["This is true for discriminated union values too. For example, sizes is most commonly ",(0,o.jsx)(n.code,{children:"'extra-small' | 'small' | 'medium' | 'large' | 'extra-large'"}),". There are two common outlier sizes ",(0,o.jsx)(n.code,{children:"tiny"})," and ",(0,o.jsx)(n.code,{children:"jumbo"}),". Avoid naming sizes ",(0,o.jsx)(n.code,{children:"ex-s"})," or ",(0,o.jsx)(n.code,{children:"hugely"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"prefer-to-minimally-distinguish-property-names",children:"Prefer to minimally distinguish property names"}),"\n",(0,o.jsxs)(n.p,{children:["If a property applies to the component or to the logical element of the component choose an unadorned name. Avoid prefixing the component name (e.g. prefer ",(0,o.jsx)(n.code,{children:"icon"})," over ",(0,o.jsx)(n.code,{children:"buttonIcon"}),") or unnecessary adjectives (e.g. prefer ",(0,o.jsx)(n.code,{children:"shape"})," over ",(0,o.jsx)(n.code,{children:"overallShape"}),")."]}),"\n",(0,o.jsxs)(n.p,{children:["If a property applies to a part or slot of a component, prefix/suffix with the part name (e.g. prefer ",(0,o.jsx)(n.code,{children:"iconPosition"})," over ",(0,o.jsx)(n.code,{children:"position"}),"). Prefer to prefix the part name except where the property is acting as a verb (e.g. ",(0,o.jsx)(n.code,{children:"alignContent"})," over ",(0,o.jsx)(n.code,{children:"contentAlign"}),")."]}),"\n",(0,o.jsx)(n.p,{children:"Avoid any hungarian notation of properties. While they can appear helpful when writing the props in Typescript, they are not idiomatic when calling from TSX."}),"\n",(0,o.jsx)(n.h3,{id:"list-properties-in-alphabetical-order",children:"List properties in alphabetical order"}),"\n",(0,o.jsx)(n.p,{children:"Trying to logically group properties is too sensitive to each developers preferences. Listing alphabetically allows developers to easily scan for a property. It also matches with how the API and storybook documentation will list properties."}),"\n",(0,o.jsx)(n.h3,{id:"avoid-re-declaring-properties-from-native-element-attributes",children:"Avoid re-declaring properties from native element attributes"}),"\n",(0,o.jsxs)(n.p,{children:["If your component provides a ",(0,o.jsx)(n.code,{children:"forwardRef"})," to a native element (e.g. Button => ",(0,o.jsx)(n.code,{children:"<button>"}),") and you intersect ",(0,o.jsx)(n.code,{children:"React.HTMLAttributes<>"}),", avoid re-declaring those attributes within your component props. Doing so can lead to type mismatch problems."]}),"\n",(0,o.jsx)(n.p,{children:"Avoid names that are commonly used in other HTML elements or attributes. They won't cause a compile or runtime error, but they may be confusing to callers."}),"\n",(0,o.jsx)(n.h3,{id:"use-discriminated-union-over-boolean-for-mutually-exclusive-props",children:"Use discriminated union over boolean for mutually exclusive props"}),"\n",(0,o.jsx)(n.p,{children:"Boolean properties are convenient to set in TSX and are appropriate for flag values."}),"\n",(0,o.jsxs)(n.p,{children:["For example, a Tooltip component may have an option to show an arrow pointing at the target. ",(0,o.jsx)(n.code,{children:"withArrow: boolean"}),". Callers can easily set this in TSX ",(0,o.jsx)(n.code,{children:"<Tooltip withArrow />"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"If there are properties that are mutually exclusive, then a discriminated union is a better choice. The caller cannot accidentally specify multiple values which could lead to unpredictable behavior."}),"\n",(0,o.jsxs)(n.p,{children:["Going back to the Tooltip component, it might have different options for position relative to the target. If these were boolean values like ",(0,o.jsx)(n.code,{children:"before?: boolean"}),", ",(0,o.jsx)(n.code,{children:"after?: boolean"}),", or ",(0,o.jsx)(n.code,{children:"cover?: boolean"}),", the caller could write ",(0,o.jsx)(n.code,{children:"<Tooltip before after cover />"}),". It is much clearer to specify ",(0,o.jsx)(n.code,{children:'<Tooltip position="before" />'}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"consider-a-discriminated-union-for-future-additional",children:"Consider a discriminated union for future additional"}),"\n",(0,o.jsxs)(n.p,{children:["If you have only a single optional value today and think there could be multiple values in the future, prefer a discriminated union with one value. For example: ",(0,o.jsx)(n.code,{children:"border: boolean"})," would have to be changed to a discriminated union later to support both square, rounded, and circular borders."]}),"\n",(0,o.jsx)(n.h3,{id:"prefer-to-inline-small--independent-discriminated-unions",children:"Prefer to inline small & independent discriminated unions"}),"\n",(0,o.jsx)(n.p,{children:"When a property type is a discriminated union, it is tempting to declare and export a type for it."}),"\n",(0,o.jsxs)(n.p,{children:["For example a size, ",(0,o.jsx)(n.code,{children:"'small' | 'medium' | 'large'"})," would be easy to define as ",(0,o.jsx)(n.code,{children:"export type Size = 'small' | 'medium' | 'large'"})," and declare ",(0,o.jsx)(n.code,{children:"size: Size;"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"There are few pitfalls with defining and exporting types for every discriminated union:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Tightly bound cross-component dependencies."}),"\n",(0,o.jsx)(n.p,{children:"If a component A uses the Size type from component B and then component B adds a value to the union, it could break component A. Component A is also less portable."}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Extra F12 navigation"}),"\n",(0,o.jsx)(n.p,{children:"Developers inspecting the props have to follow the union to understand it rather than seeing the union right next to the property. This can lead to duplicate documentation comments on property and type declarations."}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["Type explosion/collision in the type declaration files (",(0,o.jsx)(n.code,{children:".d.ts"}),")."]}),"\n",(0,o.jsx)(n.p,{children:"While types are compiled away, having many types used only in one place increases declaration file size without much benefit."}),"\n",(0,o.jsx)(n.p,{children:"Component authors have to be careful to distinguish their type from other component types (e.g. ButtonSize vs. ImageSize). Otherwise tooling might auto-import the incorrect type."}),"\n",(0,o.jsxs)(n.p,{children:["Since the practice is to place types in separate ",(0,o.jsx)(n.code,{children:".types.ts"})," files, these get exported for the component to use and can be inadvertently exported by ",(0,o.jsx)(n.code,{children:"index.ts"})," ",(0,o.jsx)(n.code,{children:"export * from ..."})]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"There are scenarios when you should consider defining a type for a discriminated union:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"It is used across multiple components within the same package, or multiple times in the same props declaration."}),"\n",(0,o.jsx)(n.li,{children:"There are many union values that it clutters the props declaration."}),"\n",(0,o.jsxs)(n.li,{children:["The type is a union of unions (e.g. ",(0,o.jsx)(n.code,{children:"color: 'brand' | 'neutral' | StatusColor"}),")"]}),"\n",(0,o.jsx)(n.li,{children:"Callers will need to use the type in TS/JS rather than in just TSX/JSX."}),"\n",(0,o.jsx)(n.li,{children:"Developers authoring variants of your component will need that type in their component props."}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},1151:(e,n,i)=>{i.d(n,{Z:()=>a,a:()=>s});var o=i(7294);const t={},r=o.createContext(t);function s(e){const n=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);